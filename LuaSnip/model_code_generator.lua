
vim.api.nvim_set_keymap('i', "<C-t>", '<cmd>lua _G.dynamic_node_external_update(1)<Cr>', {noremap = true})
vim.api.nvim_set_keymap('s', "<C-t>", '<cmd>lua _G.dynamic_node_external_update(1)<Cr>', {noremap = true})

vim.api.nvim_set_keymap('i', "<C-g>", '<cmd>lua _G.dynamic_node_external_update(2)<Cr>', {noremap = true})
vim.api.nvim_set_keymap('s', "<C-g>", '<cmd>lua _G.dynamic_node_external_update(2)<Cr>', {noremap = true})
-- ---------------dynamic node---
local util = require("luasnip.util.util")
local node_util = require("luasnip.nodes.util")
local ls        = require("luasnip")
-- some shorthands...
local s         = ls.snippet
local sn        = ls.snippet_node
local text      = ls.text_node
local insert    = ls.insert_node
local t         = ls.text_node
local i         = ls.insert_node
local f         = ls.function_node
local fmta      = require("luasnip.extras.fmt").fmta
local rep       = require("luasnip.extras").rep
local sn        = ls.snippet_node
local c         = ls.choice_node
local d         = ls.dynamic_node
local r         = ls.restore_node

local function find_dynamic_node(node)
	-- the dynamicNode-key is set on snippets generated by a dynamicNode only (its'
	-- actual use is to refer to the dynamicNode that generated the snippet).
	while not node.dynamicNode do
		node = node.parent
	end
	return node.dynamicNode
end

local external_update_id = 0
-- func_indx to update the dynamicNode with different functions.
function dynamic_node_external_update(func_indx)
	-- most of this function is about restoring the cursor to the correct
	-- position+mode, the important part are the few lines from
	-- `dynamic_node.snip:store()`.
	print("this function is called with index " .. func_indx)


	-- find current node and the innermost dynamicNode it is inside.
	local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
	local dynamic_node = find_dynamic_node(current_node)

	-- to identify current node in new snippet, if it is available.
	external_update_id = external_update_id + 1
	current_node.external_update_id = external_update_id

	-- store which mode we're in to restore later.
	local insert_pre_call = vim.fn.mode() == "i"
	-- is byte-indexed! Doesn't matter here, but important to be aware of.
	local cursor_pos_pre_relative = util.pos_sub(
		util.get_cursor_0ind(),
		current_node.mark:pos_begin_raw()
	)

	-- leave current generated snippet.
	node_util.leave_nodes_between(dynamic_node.snip, current_node)

	-- call update-function.
	local func = dynamic_node.user_args[func_indx]
	if func then

		-- the same snippet passed to the dynamicNode-function. Any output from func
		-- should be stored in it under some unused key.
		func(dynamic_node.parent.snippet)
	end

	-- last_args is used to store the last args that were used to generate the
	-- snippet. If this function is called, these will most probably not have
	-- changed, so they are set to nil, which will force an update.
	dynamic_node.last_args = nil
	dynamic_node:update()

	-- everything below here isn't strictly necessary, but it's pretty nice to have.


	-- try to find the node we marked earlier.
	local target_node = dynamic_node:find_node(function(test_node)
		return test_node.external_update_id == external_update_id
	end)

	if target_node then
		-- the node that the cursor was in when changeChoice was called exists
		-- in the active choice! Enter it and all nodes between it and this choiceNode,
		-- then set the cursor.
		node_util.enter_nodes_between(dynamic_node, target_node)

		if insert_pre_call then
			util.set_cursor_0ind(
				util.pos_add(
					target_node.mark:pos_begin_raw(),
					cursor_pos_pre_relative
				)
			)
		else
			node_util.select_node(target_node)
		end
		-- set the new current node correctly.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
	else
		-- the marked node wasn't found, just jump into the new snippet noremally.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
	end
end




---------------model
local model = function(args, parent)
	-- this could also be outside the dynamicNode.
	local nodes = { t "" }
	-- keep track of which insert-index we're at.
	local ins_indx = 1
	--local argc = tonumber(parent.captures[1])
	---- snip.argc is controlled via c-t/c-g
	local argc = parent.argc
	if not argc then
		parent.argc = 1
		argc = 1
	end

	-- store jump_indx separately and increase for each insertNode.
	local jump_indx = 1
	local jump_indx_n = 2
	-- generate variables
	for j = 1, argc do
		table.insert(nodes,t "\t final ")
		table.insert(nodes,r(jump_indx,"datatype" .. j,i(jump_indx,"datatype" .. j)))
		table.insert(nodes,t " ")
		table.insert(nodes,r(jump_indx_n,"var" .. j,i(jump_indx_n,"var" .. j)))
		table.insert(nodes,t ";")
		table.insert(nodes,t {"",""})
		jump_indx = jump_indx + 2
		jump_indx_n = jump_indx_n + 2
	end

	nodes[#nodes + 1] = t { "" }
	nodes[#nodes + 1] = t { "const " }
	nodes[#nodes + 1] = t { args[1][1] }
	nodes[#nodes + 1] = t { "({", "" }
	local jump_indx_n = 2

	-- generate constructor
	for _ = 1, argc do
		vim.list_extend(nodes, {
			t "\t required this.",
			rep(jump_indx_n),
			t { ",", "" }
		})
		jump_indx_n = jump_indx_n + 2
	end

	nodes[#nodes + 1] = t { "});", "" }
	-- generate copyWith
	nodes[#nodes + 1] = t { args[1][1] }
	nodes[#nodes + 1] = t { " copyWith " }
	nodes[#nodes + 1] = t { "({", "" }
	local jump_indx = 1
	local jump_indx_n = 2
	for _ = 1, argc  do
		vim.list_extend(nodes, {
			t "\t ",
			rep(jump_indx),
			t "? ",
			rep(jump_indx_n),
			t { ",", "" }
		})
		jump_indx = jump_indx + 2
		jump_indx_n = jump_indx_n + 2
	end

	nodes[#nodes + 1] = t { "}){", "" }
	nodes[#nodes + 1] = t { " return " }
	nodes[#nodes + 1] = t { args[1][1] }
	nodes[#nodes + 1] = t { "(", "" }
	local jump_indx_n = 2
	for j = 1, argc  do
		vim.list_extend(nodes, {
			rep(jump_indx_n),
			t ": ",
			rep(jump_indx_n),
			t "?? this.",
			rep(jump_indx_n),
			t { ",", "" }
		})
		jump_indx_n = jump_indx_n + 2
	end
	nodes[#nodes + 1] = t { ");", "" }
	nodes[#nodes + 1] = t { "}", "" }
	---- Equatable override
	nodes[#nodes + 1] = t { " @override", "" }
	nodes[#nodes + 1] = t { " List<Object> get props => [", "" }
	local jump_indx_n = 2
	for _ = 1, argc  do
		vim.list_extend(nodes, {
			rep(jump_indx_n),
			t { ",", "" }
		})
		jump_indx_n = jump_indx_n + 2
	end
	nodes[#nodes + 1] = t { "];", "" }
	nodes[#nodes + 1] = t { "}", "" }

	-- remove last linebreak.
	--nodes[#nodes] = nil

	return sn(nil, nodes)
end


--------------------model
ls.add_snippets("dart", {
-- 	s({ trig = "model(%d+)", regTrig = true }, fmta(
-- 		[[
-- import 'package:equatable/equatable.dart';
--
-- class <> extends Equatable {
--  <>
--   
--
--
-- ]], { i(1), d(2, model, { 1 }, {
--
-- 		user_args = { function(parent) parent.argc = parent.argc + 1 end,
-- 			function(parent) parent.argc = math.max(parent.argc - 1, 1) end }
--
--
--
-- 	}) )}
--
-- 	)
})
